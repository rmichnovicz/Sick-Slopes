<!--
Adapted from:
https://developers.google.com/maps/documentation/javascript/examples/places-searchbox
https://developers.google.com/maps/documentation/javascript/examples/rectangle-event
-->
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <link rel="shortcut icon" href="favicon.ico">
    <title>Sick Slopes!</title>
    <style>
      /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
      #map {
        height: 100%;
      }
      #map-container {
        height: 400px;
        width: 800px;
      }
      /* Optional: Makes the sample page fill the window. */
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      .controls {
        margin-top: 10px;
        border: 1px solid transparent;
        border-radius: 2px 0 0 2px;
        box-sizing: border-box;
        -moz-box-sizing: border-box;
        height: 32px;
        outline: none;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }

      #pac-input {
        background-color: #fff;
        font-family: Roboto;
        font-size: 15px;
        font-weight: 300;
        margin-left: 12px;
        padding: 0 11px 0 13px;
        text-overflow: ellipsis;
        width: 300px;
      }

      #pac-input:focus {
        border-color: #4d90fe;
      }

      .pac-container {
        font-family: Roboto;
      }

      #type-selector {
        color: #fff;
        background-color: #4d90fe;
        padding: 5px 11px 0px 11px;
      }

      #type-selector label {
        font-family: Roboto;
        font-size: 13px;
        font-weight: 300;
      }
      #target {
        width: 345px;
      }
    </style>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js">
      </script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <script>
      // This example adds a search box to a map, using the Google Place Autocomplete
      // feature. People can enter geographical searches. The search box will return a
      // pick list containing a mix of places and predicted search terms.

      // This example requires the Places library. Include the libraries=places
      // parameter when you first load the API. For example:
      // <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places">
      var map;
      var postURL = "localhost";
      var data;
      var graph;
      var origins;
      var results;
      var edgeHeights;
      var stoplights;
      var useStoplights;
      var nodeLatLongs;
      var maxesAndPaths;
      var polyline;
      // var sortedMaxesAndPaths = [];

      function initAutocomplete() {
        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 33.77755, lng: -84.40075},
          zoom: 13,
          mapTypeId: 'roadmap'
        });

        // Create the search box and link it to the UI element.
        var input = document.getElementById('pac-input');
        var searchBox = new google.maps.places.SearchBox(input);
        map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

        // Bias the SearchBox results towards current map's viewport.
        map.addListener('bounds_changed', function() {
          searchBox.setBounds(map.getBounds());
        });

        var markers = [];
        // Listen for the event fired when the user selects a prediction and retrieve
        // more details for that place.
        searchBox.addListener('places_changed', function() {
          var places = searchBox.getPlaces();

          if (places.length == 0) {
            return;
          }

          // Clear out the old markers.
          markers.forEach(function(marker) {
            marker.setMap(null);
          });
          markers = [];

          // For each place, get the icon, name and location.
          var bounds = new google.maps.LatLngBounds();
          places.forEach(function(place) {
            if (!place.geometry) {
              console.log("Returned place contains no geometry");
              return;
            }
            var icon = {
              url: place.icon,
              size: new google.maps.Size(71, 71),
              origin: new google.maps.Point(0, 0),
              anchor: new google.maps.Point(17, 34),
              scaledSize: new google.maps.Size(25, 25)
            };

            // Create a marker for each place.
            markers.push(new google.maps.Marker({
              map: map,
              icon: icon,
              title: place.name,
              position: place.geometry.location
            }));

            if (place.geometry.viewport) {
              // Only geocodes have viewport.
              bounds.union(place.geometry.viewport);
            } else {
              bounds.extend(place.geometry.location);
            }
          });
          map.fitBounds(bounds);
          rectangle.setBounds(bounds)
        });
        var originalRectBounds = {
          north: 33.7874,
          south: 33.7677,
          east: -84.3812,
          west: -84.4203
        };

        // Define the rectangle and set its editable property to true.
        rectangle = new google.maps.Rectangle({
          bounds: originalRectBounds,
          editable: true,
          draggable: true
        });

        rectangle.setMap(map);

        // Add an event listener on the rectangle.
        // rectangle.addListener('bounds_changed', showNewRect);
        // Not needed?

        // Define an info window on the map.
        infoWindow = new google.maps.InfoWindow();
        polyline = new google.maps.Polyline({
          strokeColor: '#FF0000',
          strokeOpacity: 1.0,
          strokeWeight: 2
        });
        polyline.setMap(map);
        // polyline.setPath([{lat: 33.7874, lng: -84.3812}, {lat: 33.7677, lng: -84.4203}])
      }

      $(document).ready(function() {

        $("#send").click(function() {
          var rectBounds = rectangle.getBounds().toJSON();
          useStoplights = $("#stoplights").prop('checked');
          var startSpeed = 1.0 //parseFloat($("#startSpeed").val());
          if (startSpeed == NaN) {
            startSpeed = 1.0;
          }
          var findPaths = generateFindPaths()
          $("#send").prop('disabled', true);
          $("#status").html("Getting Map...");
          $.ajax({
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(rectBounds),
            //dataType: 'json',
            url: '/send_square/',
            success: function(inputData) {
              data = inputData;
              console.log(data);
              graph = data["graph"];
              stoplights = data["stoplights"]
              nodeLatLongs = data["node_latlons"];
              edgeHeights = data["edge_heights"];
              $("#status").html("Got map! Finding routes...");
              $("#send").prop('disabled', false);
              origins = (useStoplights ? data["local_maxima"].
                concat(data["stoplights"]) : data["local_maxima"]);
              var paths = [];
              var maxVels = [];
              // TODO: Sort origins?
              origins.forEach(function(origin) {
                // forEach is not async, thank god
                // actual for loop is faster lol; I don't think it matters
                var newPathsAndMaxes = findPaths(
                  origin, startSpeed, [], startSpeed
                  );
                // console.log(findPaths)
                // console.log(newPathsAndMaxes[0])
                // console.log(newPathsAndMaxes[1])
                paths = paths.concat(newPathsAndMaxes[0]);
                maxVels = maxVels.concat(newPathsAndMaxes[1]);
              });
              maxesAndPaths = {};
              if (paths.length != maxVels.length) {
                console.log("Something's gone horribly wrong." +
                  " Paths is " + paths.length + " long and maxVels is " +
                  maxVels.length + "long.");
              }
              for (var i = 0, len = paths.length; i < len; i++) {
                if (maxesAndPaths[maxVels[i]] == undefined) {
                  maxesAndPaths[maxVels[i]] = [paths[i]];
                } else {
                  maxesAndPaths[maxVels[i]] =
                    maxesAndPaths[maxVels[i]].concat([paths[i]]);
                }
              }
              var sortedMaxes = Object.keys(maxesAndPaths).sort(function (a, b) {
                return (parseFloat(b) - parseFloat(a));
              })
              console.log(sortedMaxes);
              var resultContent = "";
              for (var i = 0, len = sortedMaxes.length; i < len; i++) {
                resultContent += "<h3>" + sortedMaxes[i] + "m/s </h3>"
                for (var j = 0, len2 = maxesAndPaths[sortedMaxes[i]].length;
                  j < len2; j++) {
                  resultContent +=
                    "<div class='path' data-max='" +
                    sortedMaxes[i] + "' data-iteration=" + j + ">Path " +
                    j + "</div>";
                }

              }
              $("#result-container").html(resultContent);
              $("#status").html("Found routes.");
              // $("#result-container").accordion({
              //   heightStyle: "content"
              // });
            }
          });
          return false; //recommended by tutsplus for some reason
          // https://code.tutsplus.com/tutorials/10-ways-to-instantly-increase-your-jquery-performance--net-5551
          //console.log(rectBounds);
        });
        $("#result-container").on("click", ".path", function() {
          var path = maxesAndPaths[$(this).data("max")][$(this).data("iteration")];
          var googlePath = [];
          for (var i = 0, len = path.length; i < len; i++) {
            googlePath.push({
              lat: nodeLatLongs[path[i]][0],
              lng: nodeLatLongs[path[i]][1]
            });
            polyline.setPath(googlePath);
          }
        })
      })
      function generateFindPaths() {
        function findPaths(start, vel, path, maxVel) {
          path.push(start);
          if (
            vel == 0
            || (useStoplights && stoplights.indexOf(start) != -1 && path.length > 1)
            || !(graph[start].some(function(neighbor) {
              return path.indexOf(neighbor) == -1;
              })) // TODO check if correct
            ) {
            return [[path], [maxVel]];
          }
          var paths = []
          var maxVels = []
          for(var i = 0, len = (graph[start]).length; i < len; i++) {
            var neighbor = graph[start][i];
            if (path.indexOf(neighbor) == -1) {
              var velAndMaxVel = rideDownNode(start, neighbor, vel, maxVel);
              var newPathsAndNewMaxes = findPaths(
                neighbor, velAndMaxVel[0], path, velAndMaxVel[1]
                );
              paths = paths.concat(newPathsAndNewMaxes[0]);
              maxVels = maxVels.concat(newPathsAndNewMaxes[1]);
            }
          };
          // console.log(paths);
          return [paths, maxVels];
        }
        return findPaths;
      }
      function rideDownNode(src, dest, vel, maxVel) {
        if (vel > maxVel) {
          maxVel = vel;
        }
        var distInternode = latLng2Dist(
          nodeLatLongs[src][0],
          nodeLatLongs[src][1],
          nodeLatLongs[dest][0],
          nodeLatLongs[dest][1]
          );
        var dist = distInternode / edgeHeights["(" + src + ", " + dest + ")"].length;
        var edge = edgeHeights["(" + src + ", " + dest + ")"];
        for (var i = 1, len = edge.length; i < len; i++) {
          dh = edge[i] - edge[i - 1];
          vel = newVelocity(vel, dh, dist);
          if (vel > maxVel) {
            maxVel = vel;
          }
          if (vel == 0) {
            break;
          }
        }
        return [vel, maxVel];
      }

      function latLng2Dist(lat1Raw, lng1Raw, lat2Raw, lng2Raw) {
        // This thing assumes the earth is spherical, which I think
        // hurts us less than the float -> decimal -> float conversion
        // that we're dealing with in JSON :/
        // The decimal is only accurate to .000001 deg ~ 1.1 m :'(
        var lat1 = lat1Raw * Math.PI / 180;
        // Original Python converts raw to float... IDK if we need to.
        var lng1 = lng1Raw * Math.PI / 180;
        var lat2 = lat2Raw * Math.PI / 180;
        var lng2 = lng2Raw * Math.PI / 180;
        // Radius of earth in meters, could use more precision if we
        // can figure it out for the US average.
        var radius = 6373000.0;
        var dlng = lng2 - lng1;
        var dlat = lat2 - lat1;
        var a = (Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.cos(lat1)
          * Math.cos(lat2) * Math.sin(Math.pow(dlng / 2, 2)));
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var distance = radius * c;
        return distance;
      }

      // Constants, probably to be modded by UI onclick
      var g = -9.81 // accelertion due to gravity, m/s
      var dragC = .6 // drag coefficient of human body
      var crossA = .68 // Cross-sectional area of human body
      var mass = 80 // kg
      var frictC = .03 // Coefficient of friction

      function newVelocity(v0, dh, dist) {
        if (v0 == 0) {
          return 0;
        }
        var theta = Math.atan2(dh, dist);
        var a = (
          g * Math.sin(theta)
          - (1.225 * dragC * crossA * v0 * v0) / (2 * mass)
          + (g * frictC * Math.cos(theta))
          );
        // Total Acceleration = grav, air resistance, rolling friction resistance
        // Assumes final velocity causes about the amount of air resistance as
        // inital velocity TODO: Make more classically perfect by integrating
        velSquared = 2 * a * Math.sqrt(dist * dist + dh * dh) + v0 * v0;
        if (velSquared > 0) {
          return Math.sqrt(velSquared);
        }
        return 0;
      }
    </script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDEiw0TtVlGhptMnW6UKV6KUsK6Svt3a3w&libraries=places&callback=initAutocomplete"
         async defer></script>


  </head>
  <body>
    <button id="send">Send the shit!</button><br>
    <input type="checkbox" id="stoplights">Stop at Stoplights<br>
    Starting speed, meters per second:
    <input type="text" id="startSpeed" value="1" style="width: 20em;"><br>
    <input id="pac-input" class="controls" type="text" placeholder="Search Box">
    <div id="map-container">
      <div id="map"></div>
    </div>
    <div id="status-container">
      <p id="status"></p>
    </div>
    <div id="result-container"></div>

  </body>
</html>